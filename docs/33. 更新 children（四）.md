# 更新children（四）

在本小节中，我们将会去实现 `array` => `array` 中间对比的最复杂的情况：

- 移动节点
- 新增节点

## 1. 移动节点

### 1.1 例子

```ts
const prevChildren = [
  h('p', { key: 'A' }, 'A'),
  h('p', { key: 'B' }, 'B'),
  h('p', { key: 'C' }, 'C'),
  h('p', { key: 'D' }, 'D'),
  h('p', { key: 'E' }, 'E'),
  h('p', { key: 'F' }, 'F'),
  h('p', { key: 'G' }, 'G'),
]

const nextChildren = [
  h('p', { key: 'A' }, 'A'),
  h('p', { key: 'B' }, 'B'),
  h('p', { key: 'E' }, 'E'),
  h('p', { key: 'C' }, 'C'),
  h('p', { key: 'D' }, 'D'),
  h('p', { key: 'F' }, 'F'),
  h('p', { key: 'G' }, 'G'),
]
```

- 旧节点：A B C D E F G
- 新节点：A B E C D F G
- 通过新旧对比我们发现，最终需要移动 C 的位置就好了

### 1.2 实现

#### 试想

一种暴力解法：

- 获取到混乱的部分，最终全部重排，虽然也是能够实现最终的效果的
- 但是性能有很大的浪费，因为调用 DOM API 的性能是非常差的，所以我们还是需要一种算法，来找到最精准的点。

在 Vue 3 中，使用了`最长递增子序列`的方式来获取到了稳定的序列（也就是不会变的）序列，举个例子：

- 老节点：B C D
- 新节点：D B C
- 其中 `B` 和 `D` 保持着一种稳定序列的关系，即 B 永远是在 D 的前面
- 最长递增子序列的算法就是去找到某个序列中最长的稳定序列。

通过 `getSequence` 获取递增序列的在混乱部分中的索引：

- 得到旧节点混乱部分的索引：C D E -> 2 3 4
- 得到新节点混乱部分的索引：E C D 每一项对应旧节点最终得出是：4 2 3
- 调用 `getSequence` 来获取到最长递增子序列在原数组中的索引是 `1 2`
- 对比新节点第一项 E 对应的混乱索引是 0，在最长递增子序列中不存在
- 表示要移动



#### 实现

